#pragma once
#include <string>
#include <cstdint>
#include <fcntl.h>
enum ColorMode { RGB1, RGB255, HSV };
class Color
{
public:
	float rh;
	float gs;
	float bv;
	ColorMode colorMode;
	Color operator = (const Color& alt) {
		return alt;
	}
	static uint32_t rgbToHex(int r, int g, int b);
	static uint32_t colorClassToHex(Color c);
	static Color interpolate(Color c1, Color c2, float intensity);
	Color(ColorMode colorMode, float nrh, float ngs, float nbv);
	Color() = default;
};
#pragma once
#include "Vector3.h"
#include "Vector2.h"
#include "Mesh.h"
#include "Color.h"
#include "RenderObject.h"
#include "RenderEngine.h"
#include "Matrix.h"
#include <Windows.h>
enum class WindowState {RUN, EXIT};

class MainWindow
{
public:
	MainWindow();
	~MainWindow();
	void run(HINSTANCE hInstance, int nShowCmd);
	void fatalError(LPCWSTR errorString);
	LPCWSTR _classname = L"WindowClass";
	LPCWSTR _windowname = L"Window";
	int _screenWidth;
	int _screenHeight;
	static int CoordsToBitMapIndex(Vector2 coords, int width, int height);
	static Vector2 BitMapIndexToCoords(int index, int width, int height);
	void plotLine(Vector2 p1, Vector2 p2, Color color);
	void plotTriangle(Vector2 p1, Vector2 p2, Vector2 p3, Color c, bool fill);
private:
	void initSystems(HINSTANCE hInstance, int nShowCmd);
	void mainLoop();
	void processInput();
	void drawScreen();
	void* memory;
	BITMAPINFO _bitmapInfo;
	static LRESULT CALLBACK WndProc(HWND window, UINT message, WPARAM wParam, LPARAM lParam);
	WNDCLASS _windowclass;
	HWND _window;
	WindowState _windowState;
	Mesh _mesh;
	Color color;
	RenderObject _ro;
	Matrix mat;
	Matrix mat2;
	Matrix im;
};

#pragma once
#include <vector>
class Matrix
{
public:
	std::vector<std::vector<float>> m;
	Matrix(int nsx, int nsy, float default_value);
	Matrix(int nsx, int nsy, std::vector<std::vector<float>> default_value);
	Matrix() = default;
	float sx;
	float sy;
	static Matrix im(int s) {
		Matrix temp(s,s,0);
		for (int x = 0; x < s; x++) {
			for (int y = 0; y < s; y++) {
				if (x == y) {
					temp.m[x][y] = 1;
				}
			}
		}
		return temp;
	}
	Matrix operator + (const Matrix& other) {
		if (other.sx != sx || other.sy != sy) {
			return Matrix(sx, sy, 0);
		}
		else {
			std::vector<std::vector<float>> temp = m;
			for (int r = 0; r < sx; r++) {
				for (int v = 0; v < sy; v++) {
					temp[r][v] = m[r][v] + other.m[r][v];
				}
			}
			return Matrix(sx, sy, temp);
		}
	}
	Matrix operator * (const Matrix& other) {
		if (sx != other.sy) {
			return Matrix(sx, sy, 0);
		}

		std::vector<std::vector<float>> result(sy, std::vector<float>(other.sx, 0));
		for (int i = 0; i < sy; i++) {
			for (int j = 0; j < other.sx; j++) {
				for (int k = 0; k < sx; k++) {
					result[i][j] += m[i][k] * other.m[k][j];
				}
			}
		}
		return Matrix(other.sx, sy, result);
	}
};
#pragma once
#include "Vector3.h"
#include <vector>
class Mesh
{
public:
	std::vector<Vector3> vertices;
	std::vector<int> triangles;
	Mesh(std::vector<Vector3> nvertices, std::vector<int> ntriangles);
	Mesh() = default;
};
pragma once
#include "RenderObject.h"
#include "Mesh.h"
#include <vector>

class MainWindow;

class RenderEngine
{
public:
	std::vector<RenderObject> renderQueue;
	void AddToRenderQueue(RenderObject object);
	void AddListToRenderQueue(std::vector<RenderObject> objects);
	static std::vector<RenderObject> ConvertMeshToRenderObjects(Mesh mesh, float windowWidth, float windowHeight);
};

#pragma once
#include "Color.h"
#include "Vector2.h" 
#include "Vector3.h" 
#include <vector>
class RenderObject
{
public:
	Color c;
	std::vector<Vector2> coordinates;
	RenderObject(Color nc, std::vector<Vector2>);
	RenderObject() = default;
};
#pragma once
#include "Matrix.h"
class Rotation
{
public:
	static Matrix rotZ(float amount, bool twod) {
		Matrix temp;
		if (twod) {
			temp = Matrix(2, 2, { {(float)cos(amount),(float)-sin(amount)},{(float)sin(amount),(float)cos(amount)} });
		}
		else {
			temp = Matrix(3, 3, {
			{(float)cos(amount),(float)-sin(amount), 0 },
			{(float)sin(amount),(float)cos(amount), 0 },
			{ 0,0,1 }
			});
		}
	}
	static Matrix rotY(float amount) {
		Matrix temp;
		temp = Matrix(3, 3, {
			{(float)cos(amount), 0, (float)sin(amount)},
			{0,1,0},
			{(float)-sin(amount), 0, (float)cos(amount)}
			});
		return temp;
	}
	static Matrix rotX(float amount) {
		Matrix temp;
		temp = Matrix(3, 3, {
			{ 1,0,0 },
			{0, (float)cos(amount),(float)-sin(amount)},
			{0, (float)sin(amount),(float)cos(amount),}
			});
		return temp;
	}
};

#pragma once
#include "Matrix.h"
class Vector2
{
public:
	float x = 0.0f;
	float y = 0.0f;
	Vector2(float nx, float ny);
	Vector2() = default;
	Vector2 operator + (const Vector2 &other) {
		return Vector2(x + other.x, y + other.y);
	}
	Vector2 operator - (const Vector2& other) {
		return Vector2(x - other.x, y - other.y);
	}
	Vector2 operator + (const float& other) {
		return Vector2(x + other, y + other);
	}
	Vector2 operator - (const float& other) {
		return Vector2(x - other, y - other);
	}
	Vector2 operator * (const float& other) {
		return Vector2(x * other, y * other);
	}
	Vector2 operator / (const float& other) {
		return Vector2(x / other, y / other);
	}
	Vector2 operator * (const Vector2& other) {
		return Vector2(x * other.x, y * other.y);
	}
	Vector2 operator / (const Vector2& other) {
		return Vector2(x / other.x, y / other.y);
	}
	Vector2 operator += (const Vector2& other) {
		return Vector2(x + other.x, y + other.y);
	}
	Vector2 operator -= (const Vector2& other) {
		return Vector2(x - other.x, y - other.y);
	}
	Vector2 operator += (const float& other) {
		return Vector2(x + other, y + other);
	}
	Vector2 operator -= (const float& other) {
		return Vector2(x - other, y - other);
	}
	Vector2 operator *= (const float& other) {
		return Vector2(x * other, y * other);
	}
	Vector2 operator /= (const float& other) {
		return Vector2(x / other, y / other);
	}
	Vector2 operator *= (const Vector2& other) {
		return Vector2(x * other.x, y * other.y);
	}
	Vector2 operator /= (const Vector2& other) {
		return Vector2(x / other.x, y / other.y);
	}
	operator Matrix() const {
		return Matrix(1, 2, { {x},{y} });
	}
};
#pragma once
#include "Matrix.h"
class Vector3
{
public:
	float x = 0.0f;
	float y = 0.0f;
	float z = 0.0f;
	Vector3(float nx, float ny, float nz);
	Vector3() = default;
	Vector3 operator + (const Vector3 &other) {
		return Vector3(x + other.x, y + other.y, z + other.z);
	}
	Vector3 operator - (const Vector3& other) {
		return Vector3(x - other.x, y - other.y, z - other.z);
	}
	Vector3 operator + (const float& other) {
		return Vector3(x + other, y + other, z + other);
	}
	Vector3 operator - (const float& other) {
		return Vector3(x - other, y - other, z - other);
	}
	Vector3 operator * (const float& other) {
		return Vector3(x * other, y * other, z * other);
	}
	Vector3 operator / (const float& other) {
		return Vector3(x / other, y / other, z / other);
	}
	Vector3 operator * (const Vector3& other) {
		return Vector3(x * other.x, y * other.y, z * other.z);
	}
	Vector3 operator / (const Vector3& other) {
		return Vector3(x / other.x, y / other.y, z / other.z);
	}
	Vector3 operator += (const Vector3& other) {
		return Vector3(x + other.x, y + other.y, z + other.z);
	}
	Vector3 operator -= (const Vector3& other) {
		return Vector3(x - other.x, y - other.y, z - other.z);
	}
	Vector3 operator += (const float& other) {
		return Vector3(x + other, y + other, z + other);
	}
	Vector3 operator -= (const float& other) {
		return Vector3(x - other, y - other, z - other);
	}
	Vector3 operator *= (const float& other) {
		return Vector3(x * other, y * other, z * other);
	}
	Vector3 operator /= (const float& other) {
		return Vector3(x / other, y / other, z / other);
	}
	Vector3 operator *= (const Vector3& other) {
		return Vector3(x * other.x, y * other.y, z * other.z);
	}
	Vector3 operator /= (const Vector3& other) {
		return Vector3(x / other.x, y / other.y, z / other.z);
	}
	operator Matrix() const {
		return Matrix(1, 3, { {x},{y},{z} });
	}
};
#include "Color.h"
#include <string>
#include <cmath>
#include <sstream>
#include "MainWindow.h"
Color::Color(ColorMode ncolorMode, float nrh, float ngs, float nbv) {
	colorMode = ncolorMode;
	rh = nrh;
	gs = ngs;
	bv = nbv;
}
uint32_t Color::rgbToHex(int r, int g, int b)
{
	return r * 65536 + g * 256 + b;
}
uint32_t Color::colorClassToHex(Color c)
{
	return c.rh * 65536 + c.gs * 256 + c.bv;
}
Color Color::interpolate(Color c1, Color c2, float intensity) {
	return Color(ColorMode::RGB1, c1.rh + intensity * (c2.rh - c1.rh), c1.gs + intensity * (c2.gs - c1.gs), c1.bv + intensity * (c2.bv - c1.bv));
}
#include "mainWindow.h"
#include <windows.h>
#include <WinBase.h>

int WINAPI WinMain(_In_ HINSTANCE hInstance,_In_opt_ HINSTANCE hPrevInstance,_In_ LPSTR lpCmdLine,_In_ int nShowCmd)
{
    static MainWindow mainWindow;
    mainWindow._classname = L"WindowClass";
    mainWindow._windowname = L"Window";
    mainWindow.run(hInstance, nShowCmd);
    return 0;
}
#define UNICODE
#define _UNICODE

#include <fcntl.h>
#include <io.h>
#include "MainWindow.h"
#include <iostream>
#include <sstream>
#include <cstdint>
#include <list>
#include <wingdi.h>
#include <iomanip>

MainWindow* mW;

void MainWindow::fatalError(LPCWSTR errorString) {
    MessageBox(NULL, errorString, L"Fatal Error", MB_OK);
}
int MainWindow::CoordsToBitMapIndex(Vector2 coords, int width, int height) {
    if (coords.x > width || coords.y > height) { return 0; }
    int index = coords.y * width + coords.x;
    return index;
}
Vector2 MainWindow::BitMapIndexToCoords(int index, int width, int height) {
    Vector2 coords = Vector2(0,0);
    if (index > width * height || width == 0 || height == 0) { return coords; }
    coords.y = floor(index / width);
    coords.x = floor(index % width);
}
LRESULT CALLBACK MainWindow::WndProc(HWND window, UINT message, WPARAM wParam, LPARAM lParam) {
    LRESULT result;
    switch (message) {
    case WM_CLOSE:
    {
        mW->_windowState = WindowState::EXIT;
        return 0;
    }
    case WM_EXITSIZEMOVE:
    {
        mW->drawScreen();
        return 0;
    }
    case WM_SIZING: {
        RECT* rect = (RECT*)lParam;
        int width = rect->right - rect->left;
        int height = rect->bottom - rect->top;
        if (width < 600) {rect->right = rect->left + 600;}
        if (height < 400) {rect->bottom = rect->top + 400;}
        return 0;
    }
    default:
    {
        result = DefWindowProc(window, message, wParam, lParam);
    }
    }
    return result;
}
MainWindow::MainWindow() 
{
	_screenWidth = 1688;
	_screenHeight = 1050;
	_windowState = WindowState::RUN;
	_mesh = Mesh(std::vector<Vector3> {
		Vector3(200, 100, 200),
		Vector3(200, 100, 100),
		Vector3(200, 200, 100),
		Vector3(200, 200, 200),
		Vector3(100, 100, 200),
		Vector3(100, 100, 100),
		Vector3(100, 200, 100),
		Vector3(100, 200, 200)
	},
	std::vector<int>
	{
		4, 0, 3, 4, 3, 7, 0, 1, 2, 0, 2, 3, 1, 5, 6, 1, 6, 2, 5, 4, 7, 5, 7, 6, 7, 3, 2, 7, 2, 6, 0, 5, 1, 0, 4, 5
	});
	color = Color(ColorMode::RGB1, 0.5, 0.5, 0.5);
    mat = (Matrix)Vector3(3, 4, 2);
    mat2 = Matrix(4, 3,
        { {13,9,7,15}, {8,7,4,6}, {6,4,0,3} });

    mat2 = mat * mat2;
    im = Matrix::im(4);

}
MainWindow::~MainWindow() 
{
}

void MainWindow::run(HINSTANCE hInstance, int nShowCmd)
{
    mW = this;
	initSystems(hInstance, nShowCmd);
	mainLoop();
}

void MainWindow::initSystems(HINSTANCE hInstance, int nShowCmd)
{
    _windowclass.lpfnWndProc = &MainWindow::WndProc;
    _windowclass.hInstance = hInstance;
    _windowclass.lpszClassName = _classname;
    if (!RegisterClass(&_windowclass)) { fatalError(L"Failed to register the window class"); }
    _window = CreateWindowEx(
        0,
        _classname,
        _windowname,
        WS_OVERLAPPEDWINDOW | WS_VISIBLE,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        0,
        0,
        hInstance,
        0
    );
    if (!_window) {
       fatalError(L"Failed to Create Window."); 
    }
}
void MainWindow::mainLoop()
{
    drawScreen();
    HDC hdc = GetDC(_window);
    while (_windowState != WindowState::EXIT)
    {
        processInput();
        StretchDIBits(
            hdc,
            0,
            0,
            _screenWidth,
            _screenHeight,
            0,
            0,
            _screenWidth,
            _screenHeight,
            memory,
            &_bitmapInfo,
            DIB_RGB_COLORS,
            SRCCOPY
        );
    }
    ReleaseDC(_window, hdc);
}

void MainWindow::processInput() {
    MSG msg;
    while (PeekMessage(&msg, _window, 0, 0, PM_REMOVE)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}

void MainWindow::drawScreen(){
    if (memory != nullptr)
    {
        VirtualFree(memory, 0, MEM_RELEASE);
    }
    RECT rect;
    GetClientRect(_window, &rect);
    _screenWidth = rect.right - rect.left;
    _screenHeight = rect.bottom - rect.top;
    memory = VirtualAlloc(0,
        _screenWidth * _screenHeight * 4,
        MEM_RESERVE | MEM_COMMIT,
        PAGE_READWRITE
    );
    //plotTriangle(Vector2(50, 75), Vector2(100, 50), Vector2(100,150), Color(ColorMode::RGB1, 255,0,255),false);
    std::vector<RenderObject> ros = RenderEngine::ConvertMeshToRenderObjects(_mesh, _screenWidth, _screenHeight);

    for (RenderObject ro : ros) {
        plotTriangle(ro.coordinates[0], ro.coordinates[1], ro.coordinates[2], Color(ColorMode::RGB1,255,0,0), false);
    }
    _bitmapInfo.bmiHeader.biSize = sizeof(_bitmapInfo.bmiHeader);
    _bitmapInfo.bmiHeader.biWidth = _screenWidth;
    _bitmapInfo.bmiHeader.biHeight = _screenHeight;
    _bitmapInfo.bmiHeader.biPlanes = 1;
    _bitmapInfo.bmiHeader.biBitCount = 32;
    _bitmapInfo.bmiHeader.biCompression = BI_RGB;
}
void MainWindow::plotLine(Vector2 p1, Vector2 p2, Color color) {
    int x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y;
    int dx = abs(x2 - x1), dy = abs(y2 - y1);
    int sx = x1 < x2 ? 1 : -1, sy = y1 < y2 ? 1 : -1;
    int err = dx - dy;

    while (true) {
        Vector2 coords = Vector2(x1, y1);
        int index = CoordsToBitMapIndex(coords, _screenWidth, _screenHeight);
        float intensity = abs(err - dx + dy) / (float)(dx + dy);
        std::uint32_t* pixel = (std::uint32_t*)memory;
        if (pixel) {
            pixel[index] = Color::colorClassToHex(Color::interpolate(color, Color(ColorMode::RGB1, 0, 0, 0), intensity));
        }
        if (x1 == x2 && y1 == y2) { break; };
        int e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x1 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y1 += sy;
        }
    }
}
void MainWindow::plotTriangle(Vector2 p1, Vector2 p2, Vector2 p3, Color c, bool fill) {
    plotLine(p1, p2, c);
    plotLine(p2, p3, c);
    plotLine(p3, p1, c);
}
#include "Matrix.h"

Matrix::Matrix(int nsx, int nsy, float default_value) {
	sx = nsx;
	sy = nsy;
	for (int y = 0; y < nsy; y++) {
		std::vector<float> temp = {};
		for (int x = 0; x < nsy; x++)
		{
			temp.push_back(default_value);
		}
		m.push_back(temp);
	}
}

Matrix::Matrix(int nsx, int nsy, std::vector<std::vector<float>> default_value) {
	sx = nsx;
	sy = nsy;
	m = default_value;
}
#include "Mesh.h"
Mesh::Mesh(std::vector<Vector3> nvertices, std::vector<int> ntriangles) {
	if (size(nvertices) >= 3) {
		vertices = nvertices;
	}
	if (size(ntriangles) % 3 == 0) {
		triangles = ntriangles;
	}
}

    #include "RenderEngine.h"
    void RenderEngine::AddToRenderQueue(RenderObject object) {
	    renderQueue.push_back(object);
    }
    void RenderEngine::AddListToRenderQueue(std::vector<RenderObject> objects) {
	    renderQueue.insert(std::end(renderQueue), std::begin(objects), std::end(objects));;
    }
    std::vector<RenderObject> RenderEngine::ConvertMeshToRenderObjects(Mesh mesh, float windowWidth, float windowHeight) {
        std::vector<RenderObject> arr;
        for (int i = 0; i < size(mesh.triangles); i += 3)
        {
            float aspectRatio = windowWidth / windowHeight;
            float n = 0.1;
            float f = 100.0;
            float l = -aspectRatio;
            float r = aspectRatio;
            float b = -1.0;
            float t = 1.0;
            RenderObject ro;
            for (int c = 0; c < 3; c++)
            {
                int index = i + c;
                ro.coordinates.push_back(Vector2(mesh.vertices[mesh.triangles[i + c]].x, mesh.vertices[mesh.triangles[i + c]].y));
            }
            arr.push_back(ro);
        }
        return arr;
    }
#include "RenderObject.h"
RenderObject::RenderObject(Color nc, std::vector<Vector2> ncoordinates) {
	c = nc;
	coordinates.push_back(ncoordinates[0]);
	coordinates.push_back(ncoordinates[1]);
	coordinates.push_back(ncoordinates[2]);
	//normal = Vector3(
		//(U.y * V.z) - (U.z * V.y),
		//(U.z * V.x) - (U.x * V.z),
		//(U.x * V.y) - (U.y * V.x)
	//);
}
#include "Vector2.h"
Vector2::Vector2(float nx, float ny) {
	x = nx;
	y = ny;
}
#include "Vector3.h"
Vector3::Vector3(float nx, float ny, float nz) {
	x = nx;
	y = ny;
	z = nz;
}